# -*- coding: utf-8 -*-
"""Modelagem de dados  - Caio

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lfx_29vq6qh5DuNtFGM7bkp0zPKHrhzu

### Contexto
Uma empresa do ramo de e-commerce contratou você para levantar os indicadores de
recência, frequência e ticket médio (RFM) dos seus clientes.
A saber RFM:
R (Recency): Tempo que o cliente realizou a última compra (em dias)
F (Frequency): Quantidade de compras realizadas pelo cliente
M (Monetary): Valor do ticket médio gasto pelo cliente
onde ticket médio = média do total gasto por pedido para cada cliente.
Para isso, vocês receberam uma base de dados (arquivo csv) e devem construir um
código em Python que gera um output também csv, porém contendo apenas a
identificação do cliente e métricas RFM.

## Leitura do arquivo e inspeção dos dados
"""

!pip install pandas-profiling==3.3.0

import numpy as np
import pandas as pd
from pandas_profiling import ProfileReport

import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px


import pandas as pd
from google.colab import files

df = pd.read_csv('/content/data.csv', encoding = 'latin1')
df.describe()

ProfileReport(df)

"""## Valores faltantes na identificação do cliente"""

df['CustomerID'].isna().sum()

# Número de IDs dos consumidores faltantes

df.dropna(subset = 'CustomerID',inplace = True)

"""## Preços unitários e quantidade de produtos iguais ou inferior a 0

Devemos eliminá-los

"""

# Filtro de preços - Temos 40 produtos com preço menor ou igual a zero

print(df.query('UnitPrice <= 0')['UnitPrice'].count())

# seleção de preços maiores a 0
df = df.loc[df['UnitPrice'] > 0]
df.describe()

#Realize um filtro para verificar se existem dados nulos ou menor que zero na coluna de quantidade

df.query('Quantity <= 0')['Quantity'].count()

#Filtre o dataset apenas para conter quantidade acima de zero
df = df.loc[df['Quantity'] > 0]
df.describe()

"""## Verifique se existem linhas duplicadas"""

#Verifique se tem linhas duplicadas com a função duplicated
df.duplicated().sum().any()

#Drope as linhas duplicadas

df.drop_duplicates(keep = 'first',inplace = True)
df.duplicated().sum().any()

"""## Tipos de dados da coluna"""

df.dtypes

df['CustomerID'] = df['CustomerID'].astype('int')
df['InvoiceDate'] = df['InvoiceDate'].apply(pd.to_datetime)
df.dtypes

"""##  Tratando os outliers"""

# Criar o boxplot com duas colunas do DataFrame
fig = px.box(df, y=['Quantity', 'UnitPrice'])
fig.show()

df = df.loc[(df['Quantity'] <= 10000) & (df['UnitPrice']<=5000)]
df.describe()

fig = px.box(df, y=['Quantity', 'UnitPrice'])
fig.show()

"""## Crie uma coluna adicional"""

df['Purchase'] = df['Quantity']*df['UnitPrice']
df.head()

"""##  Última data

"""

df['InvoiceDate'].max()

"""## Plotando gráficos"""

#vendas por país
salesCountry = df.groupby('Country')['Purchase'].sum().sort_values(ascending=False).head(10)

print(salesCountry)

#top 10 produtos mais vendidos
salesProducts = df.groupby('Description')['Quantity'].sum().sort_values(ascending=False).head(10)
print(salesProducts)

# vendas por mês

salesMonthly = df.groupby(df['InvoiceDate'].dt.month)['Quantity'].sum()
print(salesMonthly)

# vendas por top (mês e país)
df['month'] = df['InvoiceDate'].dt.month

salesMonthCountry = df.groupby(['month', 'Country'])['Quantity'].sum().sort_values(ascending=False).head(10)

print(salesMonthCountry)

fig = px.bar(salesCountry)
fig.update_layout(
    title="Top Sales Values per Country",
    xaxis_title="Country",
    yaxis_title="Purchases",
    showlegend=False

    )

fig.show()

fig = px.bar(salesProducts)
fig.update_layout(
    title="Top 10 products per sales",
    xaxis_title="Products",
    yaxis_title="Number of Sales",
    showlegend=False

    )

fig.show()

plt.figure(figsize=(8, 6))
plt.plot(salesMonthly, marker='o', color='b', linestyle='-', linewidth=2, markersize=8)
plt.xlim(0, 13)

plt.grid(True)

salesMonthCountry_df = salesMonthCountry.reset_index()

# Suponhamos que você tenha um DataFrame chamado df com duas colunas categóricas 'Categoria1' e 'Categoria2', e uma coluna quantitativa 'Valores'

# Criar um gráfico de barras usando seaborn
plt.figure(figsize=(10, 6))
sns.barplot(x='month', y='Quantity', hue='Country', data=salesMonthCountry_df)
plt.xlabel('Month')
plt.ylabel('Total Sells')
plt.title('Top 10 sells by country and month')
plt.show()

"""##  Cálculo do RFM"""

colunas_selecionadas = ['CustomerID',	'InvoiceNo',	'InvoiceDate',	'Quantity', 'Purchase']
novo_df = df[colunas_selecionadas]
print(novo_df)

novo_df['R'] = novo_df['InvoiceDate'] - min(novo_df['InvoiceDate'])
print(novo_df)

F = novo_df.groupby('CustomerID')['Quantity'].agg(['sum'])
print(F)

M = novo_df.groupby('CustomerID')['Purchase'].agg(['mean'])
print(M)

df1 = pd.merge(F, M, on='CustomerID', how='left')
print(df1)

novo_df = pd.merge(df1, novo_df, on= 'CustomerID', how='inner')
novo_df.drop_duplicates(subset = 'CustomerID', keep = 'first',inplace = True)
novo_df.head(100)

colunas_selecionadas = ['CustomerID',	'R',	'sum',	'mean']
RFM = novo_df[colunas_selecionadas]
RFM.rename(columns={'sum': 'F', 'mean': 'M'}, inplace=True)

RFM.to_csv('tabelaRFM.csv', index=False)
files.download('tabelaRFM.csv')